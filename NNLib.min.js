class NeuralNetwork{leakyReLUAlpha=.01;learnRate=.01;minError=.01;maxEpochs=1e3;constructor(t){this.weights=this.initializeWeights(t),this.biases=this.initializeBiases(t)}train(t){let e=structuredClone(this.weights),s=structuredClone(this.biases),r=this.getTotalError(t),h=0;for(let r=0;r<this.maxEpochs;r++){let i=[];for(let e=0;e<t.length;e++)i.push(this.makeChangeNetwork(t[e]));if(this.applyChangeNetworks(i,this.learnRate),h=this.getTotalError(t),isNaN(h))return this.weights=e,this.biases=s,this.getExitMessage(r,1,h);if(h<this.minError)return this.getExitMessage(r,0,h)}return r<h?(this.weights=e,this.biases=s,this.getExitMessage(this.maxEpochs,2,h)):this.getExitMessage(this.maxEpochs,3,h)}getExitMessage(t,e,s){return{epochs:t,exitCode:e,msg:["Finished early","NaN detected(maybe lower learnRate)(training changes revered)","Score error is greater than when started(training changes revered)","Ran out of epochs to get network error to min"][e],networkError:s}}getTotalError(t){let e=0;for(let s=0;s<t.length;s++){let r=this.getError(this.run(t[s][0]),t[s][1]);for(let t=0;t<r.length;t++)e+=r[t]**2}return e}applyChangeNetworks(t,e){let s=e/t.length;for(let e=0;e<t.length;e++){for(let r=0;r<this.weights.length;r++)for(let h=0;h<this.weights[r].length;h++)this.weights[r][h]+=t[e].weights[r][h]*s;for(let r=0;r<this.biases.length;r++)for(let h=0;h<this.biases[r].length;h++)this.biases[r][h]+=t[e].biases[r][h]*s}}makeChangeNetwork(t){let e=this.getBackwardsPassData(t),s=e[0],r=e[1],h=[];for(let t=0;t<this.weights.length;t++){h[t]=[];for(let e=0;e<this.weights[t].length;e++)h[t][e]=s[t][e%this.biases[t].length]*r[this.weights.length-t][Math.floor(e/this.biases[t].length)]}let i=[];for(let t=0;t<this.biases.length;t++){i[t]=[];for(let e=0;e<this.biases[t].length;e++)i[t][e]=s[t][e]}return{weights:h,biases:i}}getBackwardsPassData(t){let e=this.forwardPass(t[0]),s=[this.getError(e[0],t[1])];for(let t=this.weights.length-1;t>=1;t--){let r=[],h=this.biases[t-1].length;for(let i=0;i<this.weights[t].length;i++){let a=i%h,l=Math.floor(i/h);0==l&&(r[a]=0),r[a]+=s[0][l]*this.weights[t][i],l==h-1&&(r[a]*=this.leakyReLUDerivative(e[t][a]))}s.unshift(r)}return[s,e]}getError(t,e){let s=[];for(let r=0;r<t.length;r++)s[r]=e[r]-t[r];return s}run(t){return this.forwardPass(t)[0]}forwardPass(t){let e=[t];for(let t=0;t<this.weights.length;t++)e.unshift(this.forwardPassLayer(e[0],this.weights[t],this.biases[t]));return e}forwardPassLayer(t,e,s){let r=[];for(let h=0;h<e.length;h++){let i=h%t.length,a=Math.floor(h/t.length);0==i&&(r[a]=0),r[a]+=t[i]*e[h],i==t.length-1&&(r[a]=this.leakyReLU(r[a]+s[a]))}return r}leakyReLU(t){return Math.max(t,t*this.leakyReLUAlpha)}leakyReLUDerivative(t){return t>0?1:this.leakyReLUAlpha}initializeWeights(t){let e=[];for(let s=0;s<t.length-1;s++)e.push(this.createRandomArray(t[s]*t[s+1]));return e}initializeBiases(t){let e=[];for(let s=0;s<t.length-1;s++)e.push(this.createRandomArray(t[s+1]));return e}createRandomArray(t){let e=new Array(t);for(let s=0;s<t;s++)e[s]=20*Math.random()-10;return e}mutate(t=1){for(let e=0;e<t;e++)this.mutateNetwork()}mutateNetwork(){if(Math.random()<.5){let t=this.weights[Math.floor(Math.random()*this.weights.length)];t=this.mutateArray(t)}else{let t=this.biases[Math.floor(Math.random()*this.biases.length)];t=this.mutateArray(t)}}mutateArray(t){return t[Math.floor(Math.random()*t.length)]+=Math.random()-.5,t}isArray(t){return"object"==typeof t&&t.toString()!={}.toString()}clone(){let t=new NeuralNetwork([1]);return t.weights=structuredClone(this.weights),t.biases=structuredClone(this.biases),t.leakyReLUAlpha=this.leakyReLUAlpha,t.learnRate=this.learnRate,t.minError=this.minError,t.maxEpochs=this.maxEpochs,t}}